<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Generate</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<script type="module">
		import * as SudokuProcess from "./process.js";

		const generateButton = document.createElement('button');
		generateButton.style.top = '8px';
		generateButton.style.right = '8px';
		generateButton.style.position = 'absolute';
		generateButton.style.height = '32px';

		let table = null;
		let tablesProcessing = true;
		let tablesIndex = 1;
		const tablesFind = () => {
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = () => {
				if (xhttp.readyState != 4 || xhttp.status != 200) return;
				if (xhttp.responseText.length > 0) {
					const result = xhttp.responseText.split("=");
					if (result.length === 2) {
						const count = parseInt(result[1]);
						const nan = isNaN(count);
						if (!nan && count >= 0) {
							if (count >= 1e7) {
								tablesIndex++;
								tablesFind();
							} else {
								table = "puzzles" + tablesIndex;

								while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
								generateButton.appendChild(document.createTextNode(table));

								tablesProcessing = false;
							}
						}
					}
				}
			};
			const url = "./feed.php?mode=0&table=puzzles" + tablesIndex;
			xhttp.open("GET", url, true);
			xhttp.send();
		};

		const searchParams = new URLSearchParams(window.location.search);
		table = searchParams.get("table");
		if (table) {
			generateButton.appendChild(document.createTextNode(table));
			tablesProcessing = false;
		} else {
			tablesFind();
		}

		const body = document.createElement('div');
		body.style.fontFamily = "'Courier New', monospace";

		const setMessage = (message) => {
			while (body.firstChild) body.removeChild(body.lastChild);
			for (const line of message) {
				const stat = document.createElement('div');
				stat.appendChild(document.createTextNode(line));
				body.appendChild(stat);
			}
		};

		const sentDisplay = document.createElement('span');
		sentDisplay.style.position = 'absolute';
		sentDisplay.style.top = '48px';
		sentDisplay.style.right = '8px';
		sentDisplay.style.fontFamily = 'Courier New';
		sentDisplay.style.visibility = 'hidden';
		sentDisplay.textContent = "Sent: 0";
		document.body.appendChild(sentDisplay);

		let strategyCounter = null;
		let workers = null;
		const toggleWorker = () => {
			if (workers) {
				for (const worker of workers) worker.terminate();
				workers = null;
				return;
			}
			workers = [];
			if (!strategyCounter) strategyCounter = new SudokuProcess.StrategyCounter();

			const coresString = searchParams.get("cores");
			const cores = (coresString === null) ? 1 : parseInt(coresString);
			for (let i = 0; i < cores; i++) workers[i] = new Worker("worker.js", { type: "module" });
		};

		const sendDataStack = [];
		let sendDataSending = false;
		let sendDataSent = 0;
		const sendData = (currentData) => {
			if (tablesProcessing) return;
			if (currentData) sendDataStack.push(currentData);
			if (sendDataSending) return;
			sendDataSending = true;

			const currentTablesIndex = tablesIndex;
			const currentTable = table;

			const data = sendDataStack.shift();
			const puzzleData = SudokuProcess.puzzleGridHex(data.puzzleClues, data.puzzleFilled);

			let url = './generate.php?version=1';
			url += '&puzzleData=' + puzzleData;
			url += '&clueCount=' + data.clueCount;
			url += '&simple=' + data.simple;
			url += '&naked2=' + data.naked2;
			url += '&naked3=' + data.naked3;
			url += '&naked4=' + data.naked4;
			url += '&hidden2=' + data.hidden2;
			url += '&hidden3=' + data.hidden3;
			url += '&hidden4=' + data.hidden4;
			url += '&omissions=' + data.omissions;
			url += '&uniqueRectangle=' + data.uniqueRectangle;
			url += '&yWing=' + data.yWing;
			url += '&xyzWing=' + data.xyzWing;
			url += '&xWing=' + data.xWing;
			url += '&swordfish=' + data.swordfish;
			url += '&jellyfish=' + data.jellyfish;
			url += '&bruteForce=' + data.bruteForce;

			url += '&has_naked2=' + data.has_naked2;
			url += '&has_naked3=' + data.has_naked3;
			url += '&has_naked4=' + data.has_naked4;
			url += '&has_hidden2=' + data.has_hidden2;
			url += '&has_hidden3=' + data.has_hidden3;
			url += '&has_hidden4=' + data.has_hidden4;
			url += '&has_omissions=' + data.has_omissions;
			url += '&has_uniqueRectangle=' + data.has_uniqueRectangle;
			url += '&has_yWing=' + data.has_yWing;
			url += '&has_xyzWing=' + data.has_xyzWing;
			url += '&has_xWing=' + data.has_xWing;
			url += '&has_swordfish=' + data.has_swordfish;
			url += '&has_jellyfish=' + data.has_jellyfish;

			url += '&table=' + currentTable;

			fetch(url, { cache: "no-store" }).then(response => {
				response.text().then((string) => {
					const count = parseInt(string);
					const nan = isNaN(count);
					if (nan || count < 0) {
						if (workers) toggleWorker();
						return;
					}
					if (count > 0) {
						localStorage.setItem(currentTable, count);

						sendDataSent++;
						sentDisplay.textContent = "Sent: " + sendDataSent;
					} else {
						localStorage.setItem(currentTable, 1e7);
						sendDataStack.unshift(data);
					}
					if (count === 0 || count >= 1e7) {
						if (tablesIndex === currentTablesIndex) {
							tablesIndex = currentTablesIndex + 1;
							table = "puzzles" + tablesIndex;

							while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
							generateButton.appendChild(document.createTextNode(table));
						}
					}

					sendDataSending = false;
					if (sendDataStack.length > 0) sendData();
				});
			});
		};

		const processGenerate = () => {
			sentDisplay.style.visibility = 'visible';

			for (const worker of workers) {
				const workerData = {};
				workerData.run = true;
				worker.onmessage = (e) => {
					const data = e.data;
					strategyCounter.addData(data);
					setMessage(strategyCounter.lines());
					sendData(data);
				};
				worker.postMessage(workerData);
			}
		};

		generateButton.addEventListener('click', () => {
			if (tablesProcessing) return;
			toggleWorker();
			if (workers) processGenerate();
		});

		document.body.appendChild(generateButton);

		document.body.appendChild(body);
	</script>

</head>

<body></body>

</html>
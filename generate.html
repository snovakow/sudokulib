<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Generate</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<script type="module">
		import * as SudokuProcess from "./process.js";

		const MAX_SIZE = 1e7;
		const body = document.createElement('pre');
		const estimateContainer = document.createElement('pre');

		let generateMode = false;
		let pingTimer = 0;

		let statsTotals = [];
		let statsSent = [];
		let statsEstimate = [];
		const displayStats = () => {
			while (estimateContainer.firstChild) estimateContainer.removeChild(estimateContainer.firstChild);
			for (const stat of statsTotals) estimateContainer.appendChild(stat);
			estimateContainer.appendChild(document.createElement('br'));
			estimateContainer.appendChild(document.createElement('br'));
			for (const stat of statsSent) estimateContainer.appendChild(stat);
			if (statsSent.length > 0) {
				estimateContainer.appendChild(document.createElement('br'));
				estimateContainer.appendChild(document.createElement('br'));
			}
			for (const stat of statsEstimate) estimateContainer.appendChild(stat);
		};

		let tableCount = 0;
		let puzzleCount = 0;
		let totalCount = 0;
		const setCount = (table, puzzle) => {
			tableCount = table;
			puzzleCount = puzzle;
			if (tableCount > 0) totalCount = (tableCount - 1) * MAX_SIZE + puzzleCount;
		}

		let processStartTime = 0;
		let processStartCount = 0;
		let processTimer = 0;

		const options = {
			weekday: "short",
			year: "numeric",
			month: "short",
			day: "2-digit",
			hour: "2-digit",
			minute: "2-digit",
			second: "2-digit",
			second: "2-digit",
			hour12: true,
		};

		const makeBold = (title) => {
			const bolded = document.createElement('span');
			bolded.style.fontWeight = "bold";
			bolded.appendChild(document.createTextNode(title));
			return bolded;
		};

		let timeLineIndex = 0;
		const addLine = (stat, line, title) => {
			if (title) {
				const bolded = makeBold(title + ": ");
				stat.push(bolded);
			}
			stat.push(document.createTextNode(line));
		};

		const setTimeLine = () => {
			const dateNow = new Date().toLocaleString(undefined, options);
			while (statsTotals.length > timeLineIndex) statsTotals.pop();
			addLine(statsTotals, dateNow, "Time");
		}
		const populate = () => {
			statsTotals = [];

			statsTotals.push(makeBold(totalCount.toLocaleString()));
			statsTotals.push(document.createTextNode(" puzzles in "));
			statsTotals.push(makeBold(tableCount.toLocaleString()));
			statsTotals.push(document.createTextNode(tableCount === 1 ? " table" : " tables"));

			statsTotals.push(document.createElement('br'));
			statsTotals.push(document.createElement('br'));

			if (timeLineIndex === 0) timeLineIndex = statsTotals.length;
			setTimeLine();
		};

		estimateContainer.style.textAlign = "right";
		estimateContainer.style.position = "absolute";
		estimateContainer.style.top = 8 + 36 + "px";
		estimateContainer.style.right = "8px";
		document.body.appendChild(estimateContainer);

		const createEstimate = () => {
			const now = Date.now();

			if (generateMode) {
				window.requestAnimationFrame(createEstimate);
				const seconds = Math.floor(now / 1000);
				if (seconds === processTimer) return;
				processTimer = seconds;
			}

			if (processStartTime === 0) {
				processStartTime = now;
				processStartCount = totalCount;
				return;
			}

			const formatTime = (ms) => {
				const secondsTotal = Math.ceil(ms / 1000);
				const minutesTotal = Math.floor(secondsTotal / 60);
				const hoursTotal = Math.floor(minutesTotal / 60);
				const daysTotal = Math.floor(hoursTotal / 24);

				const seconds = secondsTotal % 60;
				const minutes = minutesTotal % 60;
				const hours = hoursTotal % 24;

				const secondsString = seconds < 10 ? "0" + seconds : seconds;
				const minutesString = minutes < 10 ? "0" + minutes : minutes;
				const hoursString = hours < 10 ? "0" + hours : hours;

				return `${daysTotal} days ${hoursString}:${minutesString}:${secondsString}`
			}

			setTimeLine();

			statsEstimate = [];

			const recordedCount = totalCount - processStartCount;
			const recordedTime = Date.now() - processStartTime;

			const remainingCount = MAX_SIZE - puzzleCount;

			const addEstimate = (line, title) => {
				addLine(statsEstimate, line, title);
				statsEstimate.push(document.createElement('br'));
			}

			const dateStart = new Date(processStartTime).toLocaleString(undefined, options);
			addEstimate(dateStart, "Start");
			addEstimate(formatTime(recordedTime) + " elapsed");
			statsEstimate.push(document.createElement('br'));

			if (recordedCount > 0) {
				const ms = recordedTime / recordedCount * remainingCount;
				const date = new Date(Date.now() + ms).toLocaleString(undefined, options);
				addEstimate(date, "10M ETA");
				addEstimate(formatTime(ms) + " remaining");
				const ms7 = recordedTime * MAX_SIZE / recordedCount;
				addEstimate(formatTime(ms7) + " total");
				statsEstimate.push(document.createElement('br'));
			}

			const fps = recordedCount * 1000 / recordedTime;
			statsEstimate.push(makeBold(fps.toFixed(1)));
			statsEstimate.push(document.createTextNode(" puzzles per second"));

			displayStats();
		};

		let pingCount = 0;
		let prevPingTime = Date.now();
		let prevPingCount = 0;
		const pingSend = () => {
			const url = './tables.php?version=1';
			fetch(url, { cache: "no-store" }).then(response => {
				response.text().then((string) => {
					const fields = string.split(":");
					if (fields.length !== 2) return;

					const tableCount = parseInt(fields[0]);
					if (isNaN(tableCount)) return;
					const puzzleCount = parseInt(fields[1]);
					if (isNaN(puzzleCount)) return;

					setCount(tableCount, puzzleCount);

					const maxDelay = 10 * 1000;
					const cancelDelay = 100 * 1000;
					const delay = Math.min(Math.pow(1000, 1 + (pingCount / 100)), maxDelay);

					populate();
					const now = Date.now();
					if (prevPingCount !== totalCount) {
						if (prevPingCount !== 0) createEstimate();

						prevPingTime = now;
						prevPingCount = totalCount;

					}
					displayStats();

					if (prevPingCount > 0 && (now - prevPingTime > cancelDelay)) return;

					pingTimer = window.setTimeout(() => {
						pingTimer = 0;
						pingCount++;
						pingSend();
					}, delay);
				});
			});
		};
		pingSend();

		let coreCount = 1;
		const search = new URLSearchParams(window.location.search);
		const searchCores = parseInt(search.get("cores"));
		if (!isNaN(searchCores) && searchCores < 10 && searchCores > 0) coreCount = searchCores;

		const generateButton = document.createElement('button');
		generateButton.style.top = '8px';
		generateButton.style.right = '8px';
		generateButton.style.position = 'absolute';
		generateButton.style.width = '80px';
		generateButton.style.height = '32px';
		generateButton.appendChild(document.createTextNode("Generate"));

		const setMessage = (message) => {
			body.innerText = message.join('\n');
		};

		let strategyCounter = null;
		let workers = null;
		const toggleWorker = () => {
			if (workers) {
				for (const worker of workers) worker.terminate();
				workers = null;
				return;
			}
			workers = [];
			if (!strategyCounter) strategyCounter = new SudokuProcess.StrategyCounter();

			for (let i = 0; i < coreCount; i++) workers[i] = new Worker("worker.js", { type: "module" });
		};

		const addLineSent = () => {
			statsSent = [];
			addLine(statsSent, sendDataSent, "Sent");
		}

		const sendDataStack = [];
		let sendDataSending = false;
		let sendDataSent = 0;
		const maxSend = 100;
		const sendData = (currentData) => {
			if (currentData) sendDataStack.push(currentData);
			if (sendDataSending) return;
			if (sendDataStack.length === 0) return;
			sendDataSending = true;

			const url = './generate.php?version=2';
			const readyDataSend = [];
			for (const ready of sendDataStack) {
				let post = ready;
				if (!post.puzzleData) {
					const puzzleData = SudokuProcess.puzzleGridHex(ready.puzzleClues, ready.puzzleFilled);
					post = {
						id: ready.id,
						puzzleData: puzzleData,
						clueCount: ready.clueCount,

						solveType: ready.solveType,

						hiddenSimple: ready.hiddenSimple,
						omissionSimple: ready.omissionSimple,
						nakedSimple: ready.nakedSimple,

						nakedVisible: ready.nakedVisible,
						omissionVisible: ready.omissionVisible,

						naked2: ready.naked2,
						naked3: ready.naked3,
						naked4: ready.naked4,
						hidden1: ready.hidden1,
						hidden2: ready.hidden2,
						hidden3: ready.hidden3,
						hidden4: ready.hidden4,
						omissions: ready.omissions,
						uniqueRectangle: ready.uniqueRectangle,
						yWing: ready.yWing,
						xyzWing: ready.xyzWing,
						xWing: ready.xWing,
						swordfish: ready.swordfish,
						jellyfish: ready.jellyfish,
					};
				}

				readyDataSend.push(post);
				if (readyDataSend.length === maxSend) break;
			}
			sendDataStack.splice(0, readyDataSend.length);

			fetch(url, {
				cache: "no-store",
				method: "POST",
				body: JSON.stringify(readyDataSend),
			}).then(response => {
				response.text().then((string) => {
					const fields = string.split(":");
					if (fields.length !== 2) {
						if (workers) toggleWorker();
						return;
					}

					const tableCount = parseInt(fields[0]);
					if (isNaN(tableCount)) return;
					const puzzleCount = parseInt(fields[1]);
					if (isNaN(puzzleCount)) return;

					sendDataSent += readyDataSend.length;
					addLineSent();

					setCount(tableCount, puzzleCount);
					populate();
					displayStats();

					sendDataSending = false;
					if (sendDataStack.length > 0) sendData();
				});
			});
		};

		const processGenerate = () => {
			for (const worker of workers) {
				const workerData = {};
				workerData.run = true;
				worker.onmessage = (e) => {
					const data = e.data;
					strategyCounter.addData(data);
					setMessage(strategyCounter.lines());
					sendData(data);
				};
				worker.postMessage(workerData);
			}
		};


		generateButton.addEventListener('click', () => {
			toggleWorker();
			while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
			if (pingTimer) {
				window.clearTimeout(pingTimer);
			}
			if (!generateMode && sendDataSent === 0) {
				addLineSent();
			}

			if (workers) {
				generateMode = true;
				processGenerate();
				generateButton.appendChild(document.createTextNode("Stop"));
			} else {
				generateMode = false;
				generateButton.appendChild(document.createTextNode("Generate"));
			}

			populate();
			createEstimate();
		});
		document.body.appendChild(generateButton);

		document.body.appendChild(body);

		displayStats();
	</script>

</head>

<body></body>

</html>
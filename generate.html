<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Generate</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<script type="module">
		const generateButton = document.createElement('button');
		generateButton.style.top = '8px';
		generateButton.style.right = '8px';
		generateButton.style.position = 'absolute';
		generateButton.style.height = '32px';

		let table = null;
		let tablesProcessing = true;
		let tablesIndex = 1;
		const tablesFind = () => {
			const xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = () => {
				if (xhttp.readyState != 4 || xhttp.status != 200) return;
				if (xhttp.responseText.length > 0) {
					const result = xhttp.responseText.split("=");
					if (result.length === 2) {
						const count = parseInt(result[1]);
						const nan = isNaN(count);
						if (!nan && count >= 0) {
							if (count >= 1e7) {
								tablesIndex++;
								tablesFind();
							} else {
								table = "puzzles" + tablesIndex;

								while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
								generateButton.appendChild(document.createTextNode(table));

								tablesProcessing = false;
							}
						}
					}
				}
			};
			const url = "./feed.php?mode=0&table=puzzles" + tablesIndex;
			xhttp.open("GET", url, true);
			xhttp.send();
		};

		const searchParams = new URLSearchParams(window.location.search);
		table = searchParams.get("table");
		if (table) {
			generateButton.appendChild(document.createTextNode(table));
			tablesProcessing = false;
		} else {
			tablesFind();
		}

		const body = document.createElement('div');
		body.style.fontFamily = "'Courier New', monospace";

		const setMessage = (message) => {
			while (body.firstChild) body.removeChild(body.lastChild);
			for (const line of message) {
				const stat = document.createElement('div');
				stat.appendChild(document.createTextNode(line));
				body.appendChild(stat);
			}
		};

		const sentDisplay = document.createElement('span');
		sentDisplay.style.position = 'absolute';
		sentDisplay.style.top = '48px';
		sentDisplay.style.right = '8px';
		sentDisplay.style.fontFamily = 'Courier New';
		sentDisplay.style.visibility = 'hidden';
		sentDisplay.textContent = "Sent: 0";
		document.body.appendChild(sentDisplay);

		let worker = null;
		const toggleWorker = () => {
			if (worker) {
				worker.terminate();
				worker = null;
				return;
			}
			worker = new Worker("worker.js", { type: "module" });
		};

		const byteToHex = [];
		for (let n = 0; n <= 0xff; n++) byteToHex.push(n.toString(16).padStart(2, "0"));
		const bin2hex = (buff) => {
			const hexOctets = new Array(buff.length);
			for (let i = 0; i < buff.length; i++) hexOctets[i] = byteToHex[buff[i]];
			return hexOctets.join("");
		}

		const puzzleCluesHex = (clues) => {
			const hexClues = new Uint8Array(11);
			if (clues[0] === "0") hexClues[0] = 0x00;
			else hexClues[0] = 0x01;
			let index = 1;
			for (let i = 1; i < 11; i++) {
				let char = 0x00;
				for (let offset = 0; offset < 8; offset++) {
					if (clues[index] !== "0") char |= 0x80 >>> offset;
					index++;
				}
				hexClues[i] = char;
			}
			return bin2hex(hexClues);
		}
		const puzzleGridHex = (filled) => {
			const binaryFilled = [];
			for (let row = 1; row < 8; row++) {
				for (let i = 0; i < 8; i++) {
					const index = row * 9 + i;
					const symbol = parseInt(filled[index]) - 1;

					let encode = symbol;
					if (i < encode) encode--;

					const symbolBit1 = encode % 2;
					encode = Math.floor(encode / 2);
					const symbolBit2 = encode % 2;
					encode = Math.floor(encode / 2);
					const symbolBit3 = encode % 2;

					binaryFilled.push(symbolBit3);
					binaryFilled.push(symbolBit2);
					binaryFilled.push(symbolBit1);
				}
			}
			const gridLength = 56;
			const bitLength = gridLength * 3;
			const byteLength = bitLength / 8; // 21
			const hexFilled = new Uint8Array(byteLength);
			let index = 0;
			for (let i = 0; i < byteLength; i++) {
				let char = 0x00;
				for (let offset = 0; offset < 8; offset++) {
					if (binaryFilled[index] !== 0) char |= 0x80 >>> offset;
					index++;
				}
				hexFilled[i] = char;
			}
			return bin2hex(hexFilled);
		}

		const sendDataStack = [];
		let sendDataSending = false;
		let sendDataSent = 0;
		const sendData = (currentData) => {
			if (tablesProcessing) return;
			if (currentData) sendDataStack.push(currentData);
			if (sendDataSending) return;

			const currentTablesIndex = tablesIndex;
			const currentTable = table;

			const data = sendDataStack.shift();

			const puzzleData = puzzleCluesHex(data.puzzleClues) + puzzleGridHex(data.puzzleFilled);

			let url = './generate.php?version=1';
			url += '&puzzleData=' + puzzleData;
			url += '&clueCount=' + data.clueCount;
			url += '&simple=' + data.simple;
			url += '&naked2=' + data.naked2;
			url += '&naked3=' + data.naked3;
			url += '&naked4=' + data.naked4;
			url += '&hidden2=' + data.hidden2;
			url += '&hidden3=' + data.hidden3;
			url += '&hidden4=' + data.hidden4;
			url += '&omissions=' + data.omissions;
			url += '&uniqueRectangle=' + data.uniqueRectangle;
			url += '&yWing=' + data.yWing;
			url += '&xyzWing=' + data.xyzWing;
			url += '&xWing=' + data.xWing;
			url += '&swordfish=' + data.swordfish;
			url += '&jellyfish=' + data.jellyfish;
			url += '&bruteForce=' + data.bruteForce;

			url += '&has_naked2=' + data.has_naked2;
			url += '&has_naked3=' + data.has_naked3;
			url += '&has_naked4=' + data.has_naked4;
			url += '&has_hidden2=' + data.has_hidden2;
			url += '&has_hidden3=' + data.has_hidden3;
			url += '&has_hidden4=' + data.has_hidden4;
			url += '&has_omissions=' + data.has_omissions;
			url += '&has_uniqueRectangle=' + data.has_uniqueRectangle;
			url += '&has_yWing=' + data.has_yWing;
			url += '&has_xyzWing=' + data.has_xyzWing;
			url += '&has_xWing=' + data.has_xWing;
			url += '&has_swordfish=' + data.has_swordfish;
			url += '&has_jellyfish=' + data.has_jellyfish;

			url += '&table=' + currentTable;

			fetch(url, { cache: "no-store" }).then(response => {
				response.text().then((string) => {
					const count = parseInt(string);
					const nan = isNaN(count);
					if (nan || count < 0) {
						if (worker) toggleWorker();
						return;
					}
					if (count > 0) {
						localStorage.setItem(currentTable, count);

						sendDataSent++;
						sentDisplay.textContent = "Sent: " + sendDataSent;
					} else {
						localStorage.setItem(currentTable, 1e7);
						sendDataStack.unshift(data);
					}
					if (count === 0 || count >= 1e7) {
						if (tablesIndex === currentTablesIndex) {
							tablesIndex = currentTablesIndex + 1;
							table = "puzzles" + tablesIndex;

							while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
							generateButton.appendChild(document.createTextNode(table));
						}
					}

					sendDataSending = false;
					if (sendDataStack.length > 0) sendData();
				});
			});
		};

		const processGenerate = (grids) => {
			sentDisplay.style.visibility = 'visible';

			const workerData = {};
			workerData.run = true;
			workerData.grids = grids;

			worker.onmessage = (e) => {
				const data = e.data;
				if (data.message) setMessage(data.message);
				sendData(data);
			};

			worker.postMessage(workerData);
		};

		generateButton.addEventListener('click', () => {
			if (tablesProcessing) return;
			toggleWorker();
			if (worker) processGenerate();
		});

		document.body.appendChild(generateButton);

		document.body.appendChild(body);
	</script>

</head>

<body></body>

</html>
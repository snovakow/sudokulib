<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Generate</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<script type="module">
		import * as SudokuProcess from "./process.js";

		const MAX_SIZE = 1e7;
		const body = document.createElement('pre');
		const estimateContainer = document.createElement('pre');

		let generateMode = false;
		let pingTimer = 0;

		let statsTotals = [];
		let statsSent = [];
		let statsEstimate = [];
		const displayStats = () => {
			while (estimateContainer.firstChild) estimateContainer.removeChild(estimateContainer.firstChild);
			for (const stat of statsTotals) estimateContainer.appendChild(stat);
			estimateContainer.appendChild(document.createElement('br'));
			estimateContainer.appendChild(document.createElement('br'));
			for (const stat of statsSent) estimateContainer.appendChild(stat);
			if (statsSent.length > 0) {
				estimateContainer.appendChild(document.createElement('br'));
				estimateContainer.appendChild(document.createElement('br'));
			}
			for (const stat of statsEstimate) estimateContainer.appendChild(stat);
		};

		let tableCount = 0;
		let puzzleCount = 0;
		let totalCount = 0;
		const setCount = (table, puzzle) => {
			tableCount = table;
			puzzleCount = puzzle;
			if (tableCount > 0) totalCount = (tableCount - 1) * MAX_SIZE + puzzleCount;
		}

		let processStartTime = 0;
		let processStartCount = 0;
		let processTimer = 0;

		const options = {
			weekday: "short",
			year: "numeric",
			month: "short",
			day: "2-digit",
			hour: "2-digit",
			minute: "2-digit",
			second: "2-digit",
			second: "2-digit",
			hour12: true,
		};

		const populate = () => {
			statsTotals = [];

			const total = totalCount.toLocaleString() + " puzzles in " + tableCount.toLocaleString() + " tables";
			statsTotals.push(document.createTextNode(total));
			if (!generateMode) {
				statsTotals.push(document.createElement('br'));
				statsTotals.push(document.createElement('br'));
				const date = new Date().toLocaleString(undefined, options);
				statsTotals.push(document.createTextNode(date));
			}
		};

		estimateContainer.style.textAlign = "right";
		estimateContainer.style.position = "absolute";
		estimateContainer.style.top = 8 + 36 + "px";
		estimateContainer.style.right = "8px";
		document.body.appendChild(estimateContainer);

		const createEstimate = () => {
			const now = Date.now();

			if (generateMode) {
				window.requestAnimationFrame(createEstimate);
				const seconds = Math.floor(now / 1000);
				if (seconds === processTimer) return;
				processTimer = seconds;
			}

			const formatTime = (ms) => {
				const secondsTotal = Math.ceil(ms / 1000);
				const minutesTotal = Math.floor(secondsTotal / 60);
				const hoursTotal = Math.floor(minutesTotal / 60);
				const daysTotal = Math.floor(hoursTotal / 24);

				const seconds = secondsTotal % 60;
				const minutes = minutesTotal % 60;
				const hours = hoursTotal % 24;

				const secondsString = seconds < 10 ? "0" + seconds : seconds;
				const minutesString = minutes < 10 ? "0" + minutes : minutes;
				const hoursString = hours < 10 ? "0" + hours : hours;

				return `${daysTotal} days ${hoursString}:${minutesString}:${secondsString}`
			}

			statsEstimate = [];

			const recordedCount = totalCount - processStartCount;
			const recordedTime = Date.now() - processStartTime;

			const remainingCount = MAX_SIZE - puzzleCount;

			const addLine = (line, title) => {
				if (title) {
					const bolded = document.createElement('span');
					bolded.style.fontWeight = "bold";
					bolded.appendChild(document.createTextNode(title + ": "));
					statsEstimate.push(bolded);
				}
				statsEstimate.push(document.createTextNode(line));
				statsEstimate.push(document.createElement('br'));
			};

			if (generateMode) {
				const dateNow = new Date().toLocaleString(undefined, options);
				addLine(dateNow, "Time");
				statsEstimate.push(document.createElement('br'));
			}

			const dateStart = new Date(processStartTime).toLocaleString(undefined, options);
			addLine(dateStart, "Start");
			addLine(formatTime(recordedTime) + " elapsed");
			statsEstimate.push(document.createElement('br'));

			if (recordedCount > 0) {
				const ms = recordedTime / recordedCount * remainingCount;
				const date = new Date(Date.now() + ms).toLocaleString(undefined, options);
				addLine(date, "10M ETA");
				addLine(formatTime(ms) + " remaining");
				const ms7 = recordedTime * MAX_SIZE / recordedCount;
				addLine(formatTime(ms7) + " total");
				statsEstimate.push(document.createElement('br'));
			}

			const fps = recordedCount * 1000 / recordedTime;
			addLine(fps.toFixed(1) + " puzzles per second");
		};

		let pingCount = 0;
		let prevPingTime = Date.now();
		let prevPingCount = 0;
		const pingSend = () => {
			const url = './tables.php?version=1';
			fetch(url, { cache: "no-store" }).then(response => {
				response.text().then((string) => {
					const fields = string.split(":");
					if (fields.length !== 2) return;

					const tableCount = parseInt(fields[0]);
					if (isNaN(tableCount)) return;
					const puzzleCount = parseInt(fields[1]);
					if (isNaN(puzzleCount)) return;

					setCount(tableCount, puzzleCount);

					const maxDelay = 10 * 1000;
					const cancelDelay = 100 * 1000;
					const delay = Math.min(Math.pow(1000, 1 + (pingCount / 100)), maxDelay);

					populate();
					displayStats();

					const now = Date.now();
					if (prevPingCount > 0 && (now - prevPingTime > cancelDelay)) {
						return;
					}
					if (prevPingCount !== totalCount) {
						prevPingTime = now;
						prevPingCount = totalCount;
					}

					pingTimer = window.setTimeout(() => {
						pingTimer = 0;
						pingCount++;
						pingSend();
					}, delay);
				});
			});
		};
		pingSend();

		let coreCount = 1;
		const search = new URLSearchParams(window.location.search);
		const searchCores = parseInt(search.get("cores"));
		if (!isNaN(searchCores) && searchCores < 10 && searchCores > 0) coreCount = searchCores;

		const generateButton = document.createElement('button');
		generateButton.style.top = '8px';
		generateButton.style.right = '8px';
		generateButton.style.position = 'absolute';
		generateButton.style.height = '32px';
		generateButton.appendChild(document.createTextNode("Generate"));

		const setMessage = (message) => {
			body.innerText = message.join('\n');
		};

		let strategyCounter = null;
		let workers = null;
		const toggleWorker = () => {
			if (workers) {
				for (const worker of workers) worker.terminate();
				workers = null;
				return;
			}
			workers = [];
			if (!strategyCounter) strategyCounter = new SudokuProcess.StrategyCounter();

			for (let i = 0; i < coreCount; i++) workers[i] = new Worker("worker.js", { type: "module" });
		};

		const sendDataStack = [];
		let sendDataSending = false;
		let sendDataSent = 0;
		const maxSend = 100;
		const sendData = (currentData) => {
			if (currentData) sendDataStack.push(currentData);
			if (sendDataSending) return;
			if (sendDataStack.length === 0) return;
			sendDataSending = true;

			const url = './generate.php?version=2';
			const readyDataSend = [];
			for (const ready of sendDataStack) {
				let post = ready;
				if (!post.puzzleData) {
					const puzzleData = SudokuProcess.puzzleGridHex(ready.puzzleClues, ready.puzzleFilled);
					post = {
						id: ready.id,
						puzzleData: puzzleData,
						clueCount: ready.clueCount,

						solveType: ready.solveType,

						hiddenSimple: ready.hiddenSimple,
						omissionSimple: ready.omissionSimple,
						nakedSimple: ready.nakedSimple,

						nakedVisible: ready.nakedVisible,
						omissionVisible: ready.omissionVisible,

						naked2: ready.naked2,
						naked3: ready.naked3,
						naked4: ready.naked4,
						hidden1: ready.hidden1,
						hidden2: ready.hidden2,
						hidden3: ready.hidden3,
						hidden4: ready.hidden4,
						omissions: ready.omissions,
						uniqueRectangle: ready.uniqueRectangle,
						yWing: ready.yWing,
						xyzWing: ready.xyzWing,
						xWing: ready.xWing,
						swordfish: ready.swordfish,
						jellyfish: ready.jellyfish,
					};
				}

				readyDataSend.push(post);
				if (readyDataSend.length === maxSend) break;
			}
			sendDataStack.splice(0, readyDataSend.length);

			fetch(url, {
				cache: "no-store",
				method: "POST",
				body: JSON.stringify(readyDataSend),
			}).then(response => {
				response.text().then((string) => {
					const fields = string.split(":");
					if (fields.length !== 2) {
						if (workers) toggleWorker();
						return;
					}

					const tableCount = parseInt(fields[0]);
					if (isNaN(tableCount)) return;
					const puzzleCount = parseInt(fields[1]);
					if (isNaN(puzzleCount)) return;

					sendDataSent += readyDataSend.length;
					statsSent[0] = document.createTextNode("Sent: " + sendDataSent);

					setCount(tableCount, puzzleCount);
					populate();
					displayStats();

					sendDataSending = false;
					if (sendDataStack.length > 0) sendData();
				});
			});
		};

		const processGenerate = () => {
			for (const worker of workers) {
				const workerData = {};
				workerData.run = true;
				worker.onmessage = (e) => {
					const data = e.data;
					strategyCounter.addData(data);
					setMessage(strategyCounter.lines());
					sendData(data);
				};
				worker.postMessage(workerData);
			}
		};


		generateButton.addEventListener('click', () => {
			if (processStartTime === 0) {
				processStartTime = Date.now();
				processStartCount = totalCount;
				statsSent[0] = document.createTextNode("Sent: 0");
			}

			toggleWorker();
			while (generateButton.firstChild) generateButton.removeChild(generateButton.firstChild);
			if (pingTimer) {
				window.clearTimeout(pingTimer);
			}
			if (workers) {
				generateMode = true;
				processGenerate();
				generateButton.appendChild(document.createTextNode("Stop"));
			} else {
				generateMode = false;
				generateButton.appendChild(document.createTextNode("Generate"));
			}

			populate();
			createEstimate();
			displayStats();
		});
		document.body.appendChild(generateButton);

		document.body.appendChild(body);

		displayStats();
	</script>

</head>

<body></body>

</html>